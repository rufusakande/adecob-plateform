const express = require("express");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const User = require("../models/UserModel");

// Import correct des middlewares
const {
  authMiddleware,
  adminMiddleware,
  locationAccessMiddleware,
  activityLogMiddleware,
  dataAccessMiddleware,
  rateLimitMiddleware,
  importPermissionMiddleware,
  editPermissionMiddleware,
  deletePermissionMiddleware,
  autoFilterMiddleware,
  fileValidationMiddleware,
  sessionCleanupMiddleware
} = require("../middleware/authMiddleware");

const { body, validationResult } = require("express-validator");
require("dotenv").config();

const router = express.Router();

// Utilitaires pour g√©n√©rer les tokens
const generateAccessToken = (user) => {
  return jwt.sign(
    { 
      id: user.id, 
      email: user.email, 
      role: user.role,
      departement_id: user.departement_id,
      commune_id: user.commune_id
    },
    process.env.JWT_SECRET,
    { expiresIn: "1h" }
  );
};

const generateRefreshToken = () => {
  return crypto.randomBytes(64).toString('hex');
};

// Fonction pour obtenir l'IP du client
const getClientIP = (req) => {
  return req.headers['x-forwarded-for'] || 
         req.connection.remoteAddress || 
         req.socket.remoteAddress ||
         (req.connection.socket ? req.connection.socket.remoteAddress : null);
};

// üìå Obtenir la liste des d√©partements et communes
router.get("/locations", 
  rateLimitMiddleware(50, 15 * 60 * 1000), // 50 requ√™tes par 15 minutes
  sessionCleanupMiddleware,
  (req, res) => {
    User.getDepartements((err, departements) => {
      if (err) {
        console.error("Erreur r√©cup√©ration d√©partements:", err);
        return res.status(500).json({ 
          success: false, 
          message: "Erreur lors de la r√©cup√©ration des d√©partements" 
        });
      }

      User.getAllCommunes((err, communes) => {
        if (err) {
          console.error("Erreur r√©cup√©ration communes:", err);
          return res.status(500).json({ 
            success: false, 
            message: "Erreur lors de la r√©cup√©ration des communes" 
          });
        }

        res.json({
          success: true,
          data: {
            departements,
            communes
          }
        });
      });
    });
  }
);

// üìå Obtenir les communes d'un d√©partement sp√©cifique
router.get("/communes/:departement_id", 
  rateLimitMiddleware(100, 15 * 60 * 1000),
  sessionCleanupMiddleware,
  (req, res) => {
    const { departement_id } = req.params;

    // Validation de l'ID du d√©partement
    if (!departement_id || isNaN(departement_id)) {
      return res.status(400).json({ 
        success: false, 
        message: "ID de d√©partement invalide" 
      });
    }

    User.getCommunesByDepartement(departement_id, (err, communes) => {
      if (err) {
        console.error("Erreur r√©cup√©ration communes par d√©partement:", err);
        return res.status(500).json({ 
          success: false, 
          message: "Erreur lors de la r√©cup√©ration des communes" 
        });
      }

      res.json({
        success: true,
        data: communes
      });
    });
  }
);

// üìå Inscription d'un utilisateur
router.post("/register", [
  // Rate limiting plus strict pour l'inscription
  rateLimitMiddleware(5, 15 * 60 * 1000), // 5 tentatives par 15 minutes
  sessionCleanupMiddleware,
  
  // Validations
  body("nom")
    .notEmpty()
    .withMessage("Le nom est requis")
    .isLength({ min: 2, max: 100 })
    .withMessage("Le nom doit contenir entre 2 et 100 caract√®res")
    .trim()
    .escape(),
  
  body("prenom")
    .notEmpty()
    .withMessage("Le pr√©nom est requis")
    .isLength({ min: 2, max: 100 })
    .withMessage("Le pr√©nom doit contenir entre 2 et 100 caract√®res")
    .trim()
    .escape(),
  
  body("email")
    .isEmail()
    .withMessage("Email invalide")
    .normalizeEmail()
    .isLength({ max: 255 })
    .withMessage("Email trop long"),
  
  body("telephone")
    .optional()
    .isMobilePhone("any")
    .withMessage("Num√©ro de t√©l√©phone invalide"),
  
  body("mot_de_passe")
    .isLength({ min: 8 })
    .withMessage("Le mot de passe doit contenir au moins 8 caract√®res")
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .withMessage("Le mot de passe doit contenir au moins une minuscule, une majuscule, un chiffre et un caract√®re sp√©cial"),
  
  body("departement_id")
    .isInt({ min: 1 })
    .withMessage("D√©partement requis"),
  
  body("commune_id")
    .isInt({ min: 1 })
    .withMessage("Commune requise")
], async (req, res) => {
  try {
    // V√©rifier les erreurs de validation
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: "Donn√©es invalides",
        errors: errors.array()
      });
    }

    const { nom, prenom, email, telephone, mot_de_passe, departement_id, commune_id } = req.body;

    // V√©rifier si l'email existe d√©j√†
    User.checkEmailExists(email, async (err, results) => {
      if (err) {
        console.error("Erreur v√©rification email:", err);
        return res.status(500).json({ 
          success: false, 
          message: "Erreur serveur lors de la v√©rification de l'email" 
        });
      }

      if (results.length > 0) {
        return res.status(409).json({ 
          success: false, 
          message: "Un compte avec cet email existe d√©j√†" 
        });
      }

      // Hasher le mot de passe avec un co√ªt plus √©lev√©
      const hashedPassword = await bcrypt.hash(mot_de_passe, 12);

      const userData = {
        nom: nom.trim(),
        prenom: prenom.trim(),
        email: email.toLowerCase().trim(),
        telephone: telephone ? telephone.trim() : null,
        mot_de_passe: hashedPassword,
        role: 'membre', // Par d√©faut, les nouveaux utilisateurs sont des membres
        departement_id: parseInt(departement_id),
        commune_id: parseInt(commune_id)
      };

      User.create(userData, (err, result) => {
        if (err) {
          console.error("Erreur cr√©ation utilisateur:", err);
          return res.status(500).json({ 
            success: false, 
            message: "Erreur lors de l'inscription" 
          });
        }

        // Logger l'activit√©
        const logData = {
          utilisateur_id: result.insertId,
          action: 'INSCRIPTION',
          description: `Inscription de ${prenom} ${nom}`,
          table_concernee: 'utilisateurs',
          id_enregistrement: result.insertId,
          donnees_apres: JSON.stringify({ nom, prenom, email, role: 'membre' }),
          adresse_ip: getClientIP(req),
          user_agent: req.headers['user-agent']
        };

        User.logActivity(logData, (logErr) => {
          if (logErr) {
            console.error("Erreur lors du logging de l'inscription:", logErr);
          }
        });

        res.status(201).json({ 
          success: true, 
          message: "Inscription r√©ussie ‚úÖ",
          data: {
            id: result.insertId,
            nom: userData.nom,
            prenom: userData.prenom,
            email: userData.email
          }
        });
      });
    });

  } catch (error) {
    console.error("Erreur inscription:", error);
    res.status(500).json({ 
      success: false, 
      message: "Erreur serveur lors de l'inscription" 
    });
  }
});

// üìå Connexion d'un utilisateur
router.post("/login", [
  rateLimitMiddleware(10, 15 * 60 * 1000), // 10 tentatives par 15 minutes
  sessionCleanupMiddleware,
  
  body("email")
    .isEmail()
    .withMessage("Email invalide")
    .normalizeEmail(),
  
  body("mot_de_passe")
    .notEmpty()
    .withMessage("Mot de passe requis")
], async (req, res) => {
  try {
    // V√©rifier les erreurs de validation
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: "Donn√©es invalides",
        errors: errors.array()
      });
    }

    const { email, mot_de_passe } = req.body;

    User.findByEmail(email.toLowerCase().trim(), async (err, results) => {
      if (err) {
        console.error("Erreur recherche utilisateur:", err);
        return res.status(500).json({ 
          success: false, 
          message: "Erreur serveur" 
        });
      }

      if (results.length === 0) {
        return res.status(401).json({ 
          success: false, 
          message: "Email ou mot de passe incorrect" 
        });
      }

      const user = results[0];

      // V√©rifier si l'utilisateur est actif
      if (user.statut !== 'actif') {
        return res.status(401).json({ 
          success: false, 
          message: "Compte inactif ou suspendu. Contactez l'administrateur." 
        });
      }

      try {
        const isMatch = await bcrypt.compare(mot_de_passe, user.mot_de_passe);
        if (!isMatch) {
          return res.status(401).json({ 
            success: false, 
            message: "Email ou mot de passe incorrect" 
          });
        }

        // G√©n√©rer les tokens
        const accessToken = generateAccessToken(user);
        const refreshToken = generateRefreshToken();

        // Cr√©er la session
        const sessionData = {
          utilisateur_id: user.id,
          refresh_token: refreshToken,
          expire_le: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 jours
          adresse_ip: getClientIP(req),
          user_agent: req.headers['user-agent']
        };

        User.createSession(sessionData, (err) => {
          if (err) {
            console.error("Erreur cr√©ation session:", err);
          }
        });

        // Mettre √† jour la derni√®re connexion
        User.updateLastLogin(user.id, (err) => {
          if (err) {
            console.error("Erreur mise √† jour derni√®re connexion:", err);
          }
        });

        // Logger l'activit√©
        const logData = {
          utilisateur_id: user.id,
          action: 'CONNEXION',
          description: `Connexion de ${user.prenom} ${user.nom}`,
          table_concernee: 'utilisateurs',
          id_enregistrement: user.id,
          adresse_ip: getClientIP(req),
          user_agent: req.headers['user-agent']
        };

        User.logActivity(logData, (err) => {
          if (err) {
            console.error("Erreur lors du logging de la connexion:", err);
          }
        });

        // R√©pondre avec les informations utilisateur (sans le mot de passe)
        const userData = {
          id: user.id,
          nom: user.nom,
          prenom: user.prenom,
          email: user.email,
          telephone: user.telephone,
          role: user.role,
          departement: {
            id: user.departement_id,
            nom: user.departement_nom,
            code: user.departement_code
          },
          commune: {
            id: user.commune_id,
            nom: user.commune_nom,
            code: user.commune_code
          },
          date_inscription: user.date_inscription,
          derniere_connexion: user.derniere_connexion
        };

        res.json({ 
          success: true,
          message: "Connexion r√©ussie ‚úÖ",
          data: {
            accessToken,
            refreshToken,
            user: userData
          }
        });

      } catch (error) {
        console.error("Erreur lors de la v√©rification du mot de passe:", error);
        res.status(500).json({ 
          success: false, 
          message: "Erreur serveur lors de la connexion" 
        });
      }
    });

  } catch (error) {
    console.error("Erreur connexion:", error);
    res.status(500).json({ 
      success: false, 
      message: "Erreur serveur lors de la connexion" 
    });
  }
});

// üìå Rafra√Æchir le token d'acc√®s
router.post("/refresh", 
  rateLimitMiddleware(30, 15 * 60 * 1000),
  sessionCleanupMiddleware,
  (req, res) => {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return res.status(401).json({ 
        success: false, 
        message: "Refresh token manquant" 
      });
    }

    User.findSessionByToken(refreshToken, (err, results) => {
      if (err) {
        console.error("Erreur recherche session:", err);
        return res.status(500).json({ 
          success: false, 
          message: "Erreur serveur" 
        });
      }

      if (results.length === 0) {
        return res.status(403).json({ 
          success: false, 
          message: "Refresh token invalide ou expir√©" 
        });
      }

      const session = results[0];
      
      // V√©rifier si la session n'est pas expir√©e
      if (new Date() > new Date(session.expire_le)) {
        return res.status(403).json({ 
          success: false, 
          message: "Session expir√©e" 
        });
      }
      
      // R√©cup√©rer les informations compl√®tes de l'utilisateur
      User.findById(session.utilisateur_id, (err, userResults) => {
        if (err) {
          console.error("Erreur recherche utilisateur pour refresh:", err);
          return res.status(500).json({ 
            success: false, 
            message: "Erreur serveur" 
          });
        }

        if (userResults.length === 0) {
          return res.status(404).json({ 
            success: false, 
            message: "Utilisateur introuvable" 
          });
        }

        const user = userResults[0];

        // V√©rifier si l'utilisateur est toujours actif
        if (user.statut !== 'actif') {
          return res.status(401).json({ 
            success: false, 
            message: "Compte inactif ou suspendu" 
          });
        }

        const newAccessToken = generateAccessToken(user);

        res.json({ 
          success: true,
          data: {
            accessToken: newAccessToken
          }
        });
      });
    });
  }
);

// üìå D√©connexion
router.post("/logout", 
  authMiddleware,
  activityLogMiddleware('DECONNEXION', 'D√©connexion utilisateur'),
  (req, res) => {
    const { refreshToken } = req.body;

    if (refreshToken) {
      User.deleteSession(refreshToken, (err) => {
        if (err) {
          console.error("Erreur suppression session:", err);
        }
      });
    }

    // Les informations pour le log sont automatiquement g√©r√©es par activityLogMiddleware
    req.activityLog.table_concernee = 'sessions_utilisateur';

    res.json({ 
      success: true, 
      message: "D√©connexion r√©ussie ‚úÖ" 
    });
  }
);

// üìå R√©cup√©ration des informations de l'utilisateur connect√©
router.get("/me", 
  authMiddleware,
  dataAccessMiddleware,
  (req, res) => {
    User.findById(req.user.id, (err, results) => {
      if (err) {
        console.error("Erreur recherche utilisateur /me:", err);
        return res.status(500).json({ 
          success: false, 
          message: "Erreur serveur" 
        });
      }

      if (results.length === 0) {
        return res.status(404).json({ 
          success: false, 
          message: "Utilisateur introuvable" 
        });
      }

      const user = results[0];
      const userData = {
        id: user.id,
        nom: user.nom,
        prenom: user.prenom,
        email: user.email,
        telephone: user.telephone,
        role: user.role,
        statut: user.statut,
        departement: {
          id: user.departement_id,
          nom: user.departement_nom,
          code: user.departement_code
        },
        commune: {
          id: user.commune_id,
          nom: user.commune_nom,
          code: user.commune_code
        },
        date_inscription: user.date_inscription,
        derniere_connexion: user.derniere_connexion
      };

      res.json({ 
        success: true,
        data: userData 
      });
    });
  }
);

// üìå Mise √† jour du profil utilisateur
router.put("/profile", 
  authMiddleware,
  dataAccessMiddleware,
  activityLogMiddleware('MISE_A_JOUR_PROFIL', (req) => `Mise √† jour du profil de ${req.user.prenom} ${req.user.nom}`),
  [
    body("nom")
      .optional()
      .isLength({ min: 2, max: 100 })
      .withMessage("Le nom doit contenir entre 2 et 100 caract√®res")
      .trim()
      .escape(),
    
    body("prenom")
      .optional()
      .isLength({ min: 2, max: 100 })
      .withMessage("Le pr√©nom doit contenir entre 2 et 100 caract√®res")
      .trim()
      .escape(),
    
    body("telephone")
      .optional()
      .isMobilePhone("any")
      .withMessage("Num√©ro de t√©l√©phone invalide"),
    
    body("mot_de_passe_actuel")
      .optional()
      .notEmpty()
      .withMessage("Mot de passe actuel requis pour le changement"),
    
    body("nouveau_mot_de_passe")
      .optional()
      .isLength({ min: 8 })
      .withMessage("Le nouveau mot de passe doit contenir au moins 8 caract√®res")
      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
      .withMessage("Le nouveau mot de passe doit contenir au moins une minuscule, une majuscule, un chiffre et un caract√®re sp√©cial")
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: "Donn√©es invalides",
          errors: errors.array()
        });
      }

      const { nom, prenom, telephone, mot_de_passe_actuel, nouveau_mot_de_passe } = req.body;
      const userId = req.user.id;

      // R√©cup√©rer les donn√©es actuelles pour le log
      User.findById(userId, async (err, results) => {
        if (err || results.length === 0) {
          return res.status(404).json({ 
            success: false, 
            message: "Utilisateur introuvable" 
          });
        }

        const currentUser = results[0];
        const updateData = {};

        // Pr√©parer les donn√©es √† mettre √† jour
        if (nom && nom !== currentUser.nom) updateData.nom = nom.trim();
        if (prenom && prenom !== currentUser.prenom) updateData.prenom = prenom.trim();
        if (telephone && telephone !== currentUser.telephone) updateData.telephone = telephone.trim();

        // Gestion du changement de mot de passe
        if (nouveau_mot_de_passe) {
          if (!mot_de_passe_actuel) {
            return res.status(400).json({
              success: false,
              message: "Mot de passe actuel requis pour changer le mot de passe"
            });
          }

          const isCurrentPasswordValid = await bcrypt.compare(mot_de_passe_actuel, currentUser.mot_de_passe);
          if (!isCurrentPasswordValid) {
            return res.status(400).json({
              success: false,
              message: "Mot de passe actuel incorrect"
            });
          }

          updateData.mot_de_passe = await bcrypt.hash(nouveau_mot_de_passe, 12);
        }

        // Si aucune donn√©e √† mettre √† jour
        if (Object.keys(updateData).length === 0) {
          return res.status(400).json({
            success: false,
            message: "Aucune modification d√©tect√©e"
          });
        }

        // Effectuer la mise √† jour
        User.updateProfile(userId, updateData, (err, result) => {
          if (err) {
            console.error("Erreur mise √† jour profil:", err);
            return res.status(500).json({
              success: false,
              message: "Erreur lors de la mise √† jour du profil"
            });
          }

          // Pr√©parer les donn√©es pour le log
          req.activityLog.table_concernee = 'utilisateurs';
          req.activityLog.id_enregistrement = userId;
          req.activityLog.donnees_avant = JSON.stringify({
            nom: currentUser.nom,
            prenom: currentUser.prenom,
            telephone: currentUser.telephone
          });
          req.activityLog.donnees_apres = JSON.stringify(updateData);

          res.json({
            success: true,
            message: "Profil mis √† jour avec succ√®s ‚úÖ",
            data: {
              nom: updateData.nom || currentUser.nom,
              prenom: updateData.prenom || currentUser.prenom,
              telephone: updateData.telephone || currentUser.telephone
            }
          });
        });
      });

    } catch (error) {
      console.error("Erreur mise √† jour profil:", error);
      res.status(500).json({
        success: false,
        message: "Erreur serveur lors de la mise √† jour du profil"
      });
    }
  }
);

// üìå Nettoyage des sessions expir√©es (route utilitaire)
router.post("/cleanup-sessions", 
  authMiddleware,
  adminMiddleware,
  activityLogMiddleware('NETTOYAGE_SESSIONS', 'Nettoyage des sessions expir√©es'),
  (req, res) => {
    User.cleanExpiredSessions((err, result) => {
      if (err) {
        console.error("Erreur nettoyage sessions:", err);
        return res.status(500).json({ 
          success: false, 
          message: "Erreur lors du nettoyage" 
        });
      }

      req.activityLog.table_concernee = 'sessions_utilisateur';
      req.activityLog.description = `${result.affectedRows} sessions expir√©es supprim√©es`;

      res.json({ 
        success: true, 
        message: `${result.affectedRows} sessions expir√©es supprim√©es ‚úÖ`,
        data: {
          sessions_supprimees: result.affectedRows
        }
      });
    });
  }
);

// üìå Obtenir les statistiques d'utilisation (pour les admins)
router.get("/stats", 
  authMiddleware,
  adminMiddleware,
  (req, res) => {
    // Cette route pourrait √™tre √©tendue pour fournir des statistiques d'utilisation
    User.getUserStats((err, stats) => {
      if (err) {
        console.error("Erreur r√©cup√©ration statistiques:", err);
        return res.status(500).json({
          success: false,
          message: "Erreur lors de la r√©cup√©ration des statistiques"
        });
      }

      res.json({
        success: true,
        data: stats
      });
    });
  }
);

// üìå Route de sant√© pour v√©rifier le statut de l'API
router.get("/health", 
  rateLimitMiddleware(100, 5 * 60 * 1000), // 100 requ√™tes par 5 minutes
  (req, res) => {
    res.json({
      success: true,
      message: "API Auth fonctionnelle",
      timestamp: new Date().toISOString(),
      version: "1.0.0"
    });
  }
);

module.exports = router;